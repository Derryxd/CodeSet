# -*- coding: utf-8 -*-
"""
Created on Thu Mar  1 10:38:47 2018

@author: ldz
"""
# =============================================================================
'''Simple SMO algrithom'''
# =============================================================================
from random import uniform
from numpy import loadtxt,mat,shape,zeros,multiply,arange,array
import matplotlib.pyplot as plt
from matplotlib.patches import Circle

'''辅助函数'''
def selectJrand(i,m):
    '''we want to select any J not equal to i'''
    j=i 
    while (j==i):
        j = int(uniform(0,m))
    return j

def clipAlpha(aj,H,L):
    '''alpha取值在[L,H]内'''
    if aj > H: 
        aj = H
    if L > aj:
        aj = L
    return aj

'''利用numpy读取txt的数据'''
#a,aa=loadDataSet('testSet.txt')
temp = loadtxt('testSet.txt')
dataArr = temp[:,0:2]  #注意切片，不包括第三列，即j=2的这一列
labelArr = temp[:,2]
'''参数'''
C=0.6
toler=0.001
maxIter = 50

'''Simple SMO'''
dataMatrix = mat(dataArr); labelMat = mat(labelArr).transpose()
m,n = shape(dataMatrix)
alphas = mat(zeros((m,1)))
b = 0; 
iter = 0
while (iter < maxIter):
    alphaPairsChanged = 0
    for i in range(m):
        fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b
        Ei = fXi - float(labelMat[i])#if checks if an example violates KKT conditions
        if ((labelMat[i]*Ei < -toler) and (alphas[i] < C)) or ((labelMat[i]*Ei > toler) and (alphas[i] > 0)):
            j = selectJrand(i,m)
            fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b
            Ej = fXj - float(labelMat[j])
            alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();
            if (labelMat[i] != labelMat[j]):
                L = max(0, alphas[j] - alphas[i])
                H = min(C, C + alphas[j] - alphas[i])
            else:
                L = max(0, alphas[j] + alphas[i] - C)
                H = min(C, alphas[j] + alphas[i])
            if L==H: 
#                print("L==H") 
                continue
            eta = 2.0 * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T
            '''eta = -(K(x1,x1)+K(x2,x2)-2K(x1,x2))'''
            if eta >= 0: 
                #注意上公式负号，故一般小于零，大于零也有公式
#                print("eta>=0") 
                continue
            alphas[j] -= labelMat[j]*(Ei - Ej)/eta
            alphas[j] = clipAlpha(alphas[j],H,L)
            if (abs(alphas[j] - alphaJold) < 0.00001): 
#                print("j not moving enough")
                continue
            alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])
                #update i by the same amount as j
                #the update is in the oppostie direction
            b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T
            b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T
            if (0 < alphas[i]) and (C > alphas[i]): b = b1
            elif (0 < alphas[j]) and (C > alphas[j]): b = b2
            else: b = (b1 + b2)/2.0
            alphaPairsChanged += 1
            print("iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged))
    if (alphaPairsChanged == 0): iter += 1
    else: iter = 0
#    print("iteration number: %d" % iter)

'''输出结果alpha、b与支持向量'''
print( 'aphas = ' + str(alphas[alphas>0]) )
print( 'b = ' + str(b) )
svmData = []; svmLabel = []
for i in range(m):
    if alphas[i]>0.0:
        svmData.append(dataArr[i,:])
        svmLabel.append(labelArr[i])
svmData = mat(svmData)
svmLabel = mat(svmLabel)

'''计算回归系数w'''
w = zeros((n,1))
for i in range(m):
    w += multiply(alphas[i]*labelMat[i],dataMatrix[i,:].T)
    
'''画出分类结果'''
xcord0 = [];ycord0 = []
xcord1 = [];ycord1 = []
fr = open('testSet.txt')#this file was generated by 2normalGen.py
for line in fr.readlines():
    '''操作list类型读取txt'''
    lineSplit = line.strip().split('\t')
    xPt = float(lineSplit[0])
    yPt = float(lineSplit[1])
    label = int(lineSplit[2])
    if (label == -1):
        xcord0.append(xPt)
        ycord0.append(yPt)
    else:
        xcord1.append(xPt)
        ycord1.append(yPt)
fr.close()
fig = plt.figure()
ax = fig.add_subplot(111)
ax.scatter(xcord0,ycord0, marker='s', s=90)
ax.scatter(xcord1,ycord1, marker='o', s=50, c='red')
plt.title('Support Vectors Circled')
z1,z2 = shape(svmLabel)
for i in range(max(z1,z2)):
    circle = Circle((svmData[i,0], svmData[i,1]), 0.5, facecolor='none', edgecolor=(0,0.8,0.8), linewidth=3, alpha=0.5)
    ax.add_patch(circle)
x = array(arange(-2.0, 12.0, 0.1))
y = array((-w[0]*x - b)/w[1]);y = y.T
ax.plot(x,y)
ax.axis([-2,12,-8,6])
plt.show()

del temp,i,j,xPt,yPt,line,m,n,z1,z2
#,b1,b2